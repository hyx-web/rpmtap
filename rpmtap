#!/bin/bash
# RPM to pacman converter with dependency handling
VERSION="1.4"
REQUIRED_PKGS=("rpm" "bsdtar" "fakeroot" "sed" "grep" "rpm2cpio" "cpio" "yay")

cleanup() {
    [ -n "$work_dir" ] && rm -rf "$work_dir"
}

check_deps() {
    for pkg in "${REQUIRED_PKGS[@]}"; do
        if ! command -v "$pkg" &> /dev/null; then
            echo "错误: 需要安装 $pkg" >&2
            exit 1
        fi
    done
}

show_help() {
    echo "rpmtap v$VERSION - 将RPM包转换为pacman格式"
    echo "用法: rpmtap [选项] <rpm文件>"
    echo "选项:"
    echo "  -h, --help     显示帮助信息"
    echo "  -o, --output   指定输出目录(默认当前目录)"
    echo "  -v, --version  显示版本信息"
    echo "  -d, --nodeps   忽略依赖关系"
}

get_pacman_deps() {
    local rpm_file="$1"
    local deps=()
    local rpm_deps=$(rpm -qpR "$rpm_file"  2>/dev/null | grep -vE '^(libc|rtld|/|.so)' | sed 's/>=.*//' | sed 's/<=.*//' | sed 's/=.*//' | sed 's/.so.*//' | sed 's/(.*//')
    for dep in $rpm_deps; do
        # 检查依赖是否存在于Arch官方仓库
        if yay -Si "$dep" >/dev/null 2>&1; then
            deps+=("$dep")
        else
            echo "忽略不在Arch仓库的依赖: $dep" >&2
        fi
    done
    echo "${deps[@]}"
}

validate_arch() {
    local arch=$1
    case "$arch" in
        x86_64|i386|i586|i686|aarch64|ppc64le|s390x)
            echo "$arch"
            return 0 ;;
        noarch)
            echo "any"
            return 0 ;;
        *)
            echo "unknown"
            return 1 ;;
    esac
}

convert_rpm() {
    local rpm_file="$1"
    local output_dir="${2:-.}"
    local nodeps="${3:-false}"
    [ ! -f "$rpm_file" ] && { echo "错误: RPM文件不存在" >&2; exit 1; }
    rpm_file=$(realpath "$rpm_file")
    local pkg_name=$(rpm -qp --queryformat '%{NAME}' "$rpm_file" 2>/dev/null)
    local pkg_version=$(rpm -qp --queryformat '%{VERSION}' "$rpm_file" 2>/dev/null)
    local pkg_release=$(rpm -qp --queryformat '%{RELEASE}' "$rpm_file" 2>/dev/null | cut -d'.' -f1)
    local pkg_arch=$(rpm -qp --queryformat '%{ARCH}' "$rpm_file" 2>/dev/null) 
    pkg_arch=$(validate_arch "$pkg_arch")
    local pkg_desc=$(rpm -qp --queryformat '%{DESCRIPTION}' "$rpm_file" 2>/dev/null | sed 's/"/\\"/g')
    [ -z "$pkg_desc" ] && pkg_desc="Converted from RPM package"
    [ -z "$pkg_name" ] && { echo "错误: 无效的RPM文件" >&2; exit 1; }
    
    work_dir=$(mktemp -d)
    trap cleanup EXIT
    local pkg_dir="$work_dir/${pkg_name}-${pkg_version}-${pkg_release}-${pkg_arch}"
    mkdir -p "$pkg_dir"
    (cd "$pkg_dir" && rpm2cpio "$rpm_file" | cpio -idmv 2>/dev/null)
    
    # 获取依赖关系
    local pkg_deps=""
    if [ "$nodeps" = "false" ]; then
        pkg_deps=$(get_pacman_deps "$rpm_file")
    fi
    
    cat > "$pkg_dir/PKGBUILD" <<EOF
pkgname=$pkg_name
pkgver=$pkg_version
pkgrel=$pkg_release
pkgdesc="$pkg_desc"
source=("file://$rpm_file")
#arch=('aarch64' 'ppc64le' 's390x' 'x86_64')
arch=('$pkg_arch')
depends=($pkg_deps)
md5sums=('SKIP')

package() {
    cp -r "\$srcdir"/* "\$pkgdir"
    rm "\$pkgdir"/*.rpm
}
EOF
    (cd "$pkg_dir" && makepkg -sr --skipchecksums --noconfirm --nodeps) || {
        echo "错误: 构建失败" >&2
        exit 1
    }
    mkdir -p "$output_dir"
    mv "$pkg_dir"/*.pkg.tar.* "$output_dir" 2>/dev/null || {
        echo "警告: 未生成包文件" >&2
        exit 1
    }

    echo "构建完成: $output_dir/${pkg_name}-${pkg_version}-${pkg_release}-${pkg_arch}.pkg.tar.*"
}

main() {
    check_deps
    local output_dir="."
    local nodeps="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_help; exit 0 ;;
            -v|--version) echo "rpmtap v$VERSION"; exit 0 ;;
            -o|--output) output_dir="$2"; shift ;;
            -d|--nodeps) nodeps="true" ;;
            *) break ;;
        esac
        shift
    done

    [ -z "$1" ] && { show_help; exit 1; }
    convert_rpm "$1" "$output_dir" "$nodeps"
}

main "$@"
